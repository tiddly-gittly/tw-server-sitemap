title: $:/plugins/linonetwo/check-website/cors-explained
type: text/vnd.tiddlywiki

! Understanding CORS and Status Messages

When using the `check-website` widget, you may notice different status messages and tooltips. This document explains what they mean.

!! Status Messages

!!! "Online" with HTTP status code

When you hover over the badge and see a tooltip like `HTTP 200`, it means:

* The website responded successfully
* The plugin was able to verify the exact HTTP status code from the server
* This happens when the target website allows cross-origin requests (has proper CORS headers)

Example tooltip messages:
* `HTTP 200` - Success
* `HTTP 301 (redirected)` - Permanent redirect (when follow-redirects is enabled)
* `HTTP 302 (redirected)` - Temporary redirect (when follow-redirects is enabled)

!!! "Online" with no-cors mode

When you hover and see: `Status verified via no-cors mode (HTTP status code not available due to CORS policy)`

This means:
* The website is online and reachable
* But the browser's CORS policy prevents accessing the HTTP status code
* The plugin fell back to `no-cors` mode to verify availability
* This is completely normal for most public websites

!!! "Offline" or "Error"

Error messages will show the specific HTTP status code when available:
* `Error (404)` - Page not found (tooltip: `HTTP 404`)
* `Error (500)` - Server error (tooltip: `HTTP 500`)
* `Redirect (301)` - Redirect detected when `follow-redirects="no"` (tooltip: `HTTP 301`)

!! What is CORS?

[[CORS (Cross-Origin Resource Sharing)|https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS]] is a browser security feature that restricts web pages from making requests to a different domain than the one serving the page.

When you check a website from TiddlyWiki (running in your browser), the browser may block access to response details from other domains for security reasons.

!! Why does this happen?

Example: When you run this in your local TiddlyWiki:

```
<$check-website url="https://example.com/" label="Example" interval="3s" />
```

If `example.com` doesn't allow cross-origin requests from your TiddlyWiki's domain (e.g., `file://` protocol or your local server), the browser will:

1. First try to make a normal request to get the HTTP status code
2. If that fails due to CORS, fall back to `no-cors` mode
3. In `no-cors` mode, the browser still makes the request to check reachability
4. But it doesn't expose the HTTP status code or response headers to JavaScript
5. If the request succeeds, we know the website is online
6. The tooltip will indicate this was verified via no-cors mode

!! When will I see different modes?

You'll see ''HTTP status codes'' when:
* Checking websites that have CORS headers allowing your origin
* Checking your own server that you've configured to allow CORS
* The target website explicitly allows cross-origin requests from your domain

You'll see ''no-cors mode'' when:
* Checking public websites (like `example.com`, `google.com`) from local TiddlyWiki
* The target website doesn't have CORS headers configured to allow your origin
* The website is online and reachable, but doesn't allow cross-origin status code access

!! Is this a problem?

Browser security policies (CORS/CORP) impose limitations on what this widget can detect:

* ''Best case'': Website allows CORS → You get exact HTTP status codes (200, 404, 500, etc.)
* ''Good case'': Website doesn't have CORS but no CORP → no-cors mode works, can confirm online but not status code
* ''Limited case'': Website has strict CORP policy → Cannot reliably detect status, may show as offline even when online

!! Known Limitations

!!! Cross-Origin-Resource-Policy (CORP)

Some websites use [[Cross-Origin-Resource-Policy (CORP)|https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy]] headers for additional security. When a website has CORP enabled:

* Even `no-cors` mode will be blocked by the browser
* The widget may show "Offline" even though the website is actually online
* This is a browser security restriction, not a bug in the widget

Examples of websites that may have CORP restrictions:
* `https://talk.tidgi.fun/` - Has CORP headers, may show as offline
* Modern security-focused websites with strict cross-origin policies

!!! Inaccurate Status Detection

In `no-cors` mode, the widget cannot distinguish between different HTTP status codes:

* A 404 error may appear as "Online" because the server responded
* The actual page content doesn't matter, only server reachability
* For accurate status code detection, the target website must allow CORS

!!! Recommendations

This widget works best for:
* Monitoring your own websites where you can configure CORS headers
* Checking websites that already have permissive CORS policies
* Getting a general sense of server reachability (online vs completely offline)

This widget has limitations for:
* Websites with strict CORP policies
* Accurately detecting specific errors (404, 500) on CORS-restricted sites
* Distinguishing between "page not found" and "server online" without CORS

If you need accurate monitoring of third-party websites, consider:
* Using a backend proxy service to bypass CORS
* Using dedicated monitoring services (UptimeRobot, Pingdom, etc.)
* Monitoring websites you control where you can add CORS headers

!! Technical Details

The widget uses a multi-stage checking strategy:

```javascript
// Stage 1: Try normal fetch to get HTTP status code
try {
  const response = await fetch(url, { method: 'HEAD', cache: 'no-cache' });
  // Can read response.status here - most accurate
} catch (corsError) {
  // Stage 2: Fall back to no-cors mode with GET
  try {
    await fetch(url, { method: 'GET', mode: 'no-cors', cache: 'no-cache' });
    // Success means server responded, but can't read status code
  } catch (corpError) {
    // Stage 3: Try loading an image as final fallback
    // This can sometimes bypass CORP but is least reliable
    // May indicate server is reachable but can't verify actual page status
  }
}
```

This approach provides:
* Best accuracy when CORS is available
* Reasonable detection when only no-cors works
* Limited fallback for strict CORP policies
